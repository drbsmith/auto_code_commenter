"""! @file

# Directory Check For Headers

TODO_DOC

## Dependencies
	* os, sys
	* util.log
	* header_generator
	* function_documenter
	* python_code.CodeBlock


## Functions
	* TestModulesInDir
	* main

[generated by Auto Code Commenter at 2022-03-08 20:01:01. https://github.com/drbsmith/auto_code_commenter]
@package src"""

import os, sys

p = os.path.dirname(os.path.abspath('./src'))
sys.path.append(p)

from util.log import setup_logging
logger = setup_logging()

## go through sub folders as well?
RECURSIVE = True

def TestModulesInDir(path):
	if not path[-1] == '/':
		path += '/'

	from header_generator import CheckForHeader
	from function_documenter import FindFunctions, CheckForDocumentation
	from python_code.CodeBlock import CodeBlock

	# get files at path
	children= [os.path.join(path, child) for child in os.listdir(path)]
	directories= list(filter(os.path.isdir, children))

	for f in children:
		if '.py' in f and not '.pyc' in f and not f in directories:

			try:
				with open(f, 'r') as fp:
					rawcode = fp.read()
				code_lines = CodeBlock.ParsePython(rawcode)
				header = CheckForHeader(code_lines)

				if header is None:
					logger.info('Missing header docstring: {}'.format(f))

				# get all lines that contain a function definition
				func_lines = FindFunctions(code_lines)
				func_lines.append(len(code_lines)) # stick EoF on the list

				for i, j in zip(func_lines[:-1], func_lines[1:]):
					has_doc = code_lines[i].hasDocumentation() # CheckForDocumentation(code_lines[i])
					if not has_doc:
						logger.info('Missing function docstring: {}::{}'.format(f, code_lines[i].getFunctionName()))
			except:
				logger.error('directory_check_for_headers: {}'.format(f), exc_info = True)

	if RECURSIVE:
		for direct in directories:
			TestModulesInDir(direct)

def main():
	if len(sys.argv) < 2:
		logger.error('missing required directory path')
		return

	path = sys.argv[1]

	TestModulesInDir(path)


if __name__ == '__main__':
	main()










